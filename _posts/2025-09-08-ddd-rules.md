---
title: "Reliable Auditing for Failed Transactions in Spring"
categories:
  - Spring
toc: true
toc_sticky: true
toc_label: "Contents"
published: false
---
<!-- TODO:  -->


### Overview
---
> 도메인 주도 설계(DDD)는 복잡한 비즈니스 도메인을 효과적으로 모델링하고, 이를 소프트웨어 코드로 구현하기 위한 접근 방식. 이 글에서는 DDD의 핵심 원칙과 각 계층(도메인, 애플리케이션, 인프라스트럭처, 프레젠테이션)의 역할 및 지켜야 할 규칙들을 자세히 다루고, 각 계층 간의 엄격한 의존성 방향을 통해 시스템의 응집도를 높이고 유지보수성을 향상시키는 방법을 기술



### DDD란..?
---
DDD == 데이터 주도 설계(Domain-Driven Design)<br>
접근 방식을 의미<br>
소프트웨어를 만들 때 "코드 구조를 기술적 관점"이 아니라 **업무 도메인(비즈니스 문제 영역)**을 중심으로 설계하자는 접근 방식


**의존성 규칙: 외부 계층 → 내부 계층 (O), 내부 계층 → 외부 계층 (X)**
이는 내부 계층이 외부 계층의 구현 세부 사항에 얽매이지 않고, 순수하게 도메인 본연의 역할에 집중할 수 있도록 하기 위함입니다. 이러한 단방향 의존성은 시스템의 결합도를 낮추고, 유연성 및 테스트 용이성을 극대화합니다.
`(Presentation → Application → Domain) ← Infrastructure`


### 1. 도메인 계층 (Domain Layer)
---

> 헥사고날 아키텍처의 **"내부(Inside)"**. 시스템의 심장이며, 모든 비즈니스 규칙과 상태를 포함함. 해당 계층은 완전히 독립적이어야 함.

###### ✅ 꼭 해야 하는 것 (Do's)

1.  **풍부한(Rich) 도메인 모델 작성**
    *   엔티티(Entity)는 단순한 데이터 덩어리(Anemic Model)가 되어서는 아니됨. 반드시 자신의 상태를 스스로 변경하는 **비즈니스 로직**을 포함해야 함.
    *   *예시: `Order` 엔티티는 `order.setStatus(OrderStatus.CANCELLED)`가 아니라, `order.cancel(reason)`과 같은 비즈니스 행위 메소드를 가져야 함.*(단순한 setter X)
        - 왜?:

2.  **값 객체(Value Object) 적극적 활용**
    *   '값' 자체로 의미를 가지는 개념(예: 돈, 주소, 주문 수량)은 `int`, `String` 대신 불변(immutable)의 값 객체로 모델링A 코드의 **가독성**과 안정성이 크게 향상됨.

3.  **애그리거트(Aggregate) 단위로 모델링**
    *   하나의 트랜잭션으로 처리되어야 하는 엔티티 묶음을 '애그리거트'로 정의하고, 그 경계를 명확히 해야 함. 애그리거트 루트(Root)를 통해서만 내부에 접근하도록 강제하여 데이터 일관성을 보장.

4.  **리포지토리(Repository)는 인터페이스만 정의**
    *   데이터 영속성에 대한 **계약(추상화)**인 리포지토리 인터페이스는 도메인 계층에 속하며, 실제 구현은 인프라스트럭처 계층의 역할.

5.  **도메인 이벤트(Domain Event) 발행**
    *   애그리거트의 상태 변경 시, 도메인 이벤트를 발행하여 다른 애그리거트나 외부 시스템과의 결합도를 낮춤.


###### ❌ 절대로 하면 안 되는 것 (Don'ts)

1.  **외부 프레임워크 의존성 포함**
    *   JPA의 `@Entity`, Spring의 `@Component`, `@Transactional` 등 특정 기술에 종속적인 어노테이션이나 코드를 절대로 포함해서는 안됨. 도메인은 순수한 Java/Kotlin 코드여야 함.

2.  **인프라스트럭처 로직 포함**
    *   데이터베이스 쿼리, 외부 API 호출, 파일 시스템 접근 등 인프라스트럭처에 관련된 코드가 단 한 줄이라도 있어서는 아니됨.

3.  **애플리케이션 계층에 대한 참조**
    *   도메인은 자신을 사용하는 애플리케이션 서비스에 대해 아무것도 알아서는 아니됨.

4.  **DTO(Data Transfer Object) 참조**
    *   DTO는 외부 계층과의 데이터 교환을 위한 객체이며 도메인 모델은 DTO의 존재를 알아서는 아니됨.


### 2. 애플리케이션 계층 (Application Layer)
---

> 헥사고날 아키텍처의 **"유스케이스(Use Case)"**. 도메인 객체들을 조율(Orchestration)하여 사용자의 요청을 처리하며, 비즈니스 로직은 포함되지 아니함.

###### ✅ 꼭 해야 하는 것 (Do's)

1.  **유스케이스 단위로 서비스 구현**
    *   서비스의 각 메소드는 사용자의 특정 요구사항이나 시나리오(예: `상품 주문`, `회원 가입`)에 해당해야 함.

2.  **도메인 모델 조율(Orchestration)**
    *   주요 역할은 다음과 같습니다:
        1.  리포지토리(포트)를 통해 애그리거트를 조회
        2.  애그리거트의 비즈니스 메소드를 호출
        3.  결과를 리포지토리(포트)를 통해 저장

3.  **트랜잭션 경계 설정**
    *   유스케이스는 하나의 논리적인 작업 단위로, 트랜잭션을 시작하고 끝내기에 가장 이상적인 계층. `@Transactional` 어노테이션은 기본적으로 여기에 위치.

4.  **아웃고잉 포트(Outgoing Port)에 의존**
    *   데이터베이스 접근이나 외부 API 호출이 필요할 때, 인프라스트럭처의 구체적인 클래스가 아닌 도메인 계층에 정의된 **리포지토리 인터페이스(포트)**에 의존해야 함(인터페이스에 의존, 구현체에 의존X)

5.  **보안 및 권한 검사**
    *   유스케이스를 실행하기 전에 현재 사용자가 해당 작업을 수행할 권한이 있는지 검사하는 로직을 포함할 수 있음.

###### ❌ 절대로 하면 안 되는 것 (Don'ts)

1.  **비즈니스 로직 포함**
    *   애플리케이션 서비스 내부에 `if/else` 등으로 분기하며 비즈니스 규칙을 직접 구현해서는 아니되며, 해당 로직은 도메인 모델 내부로 옮겨져야 함.

2.  **인프라스트럭처에 직접 의존** (인터페이스만 의존)
    *   `JpaRepository` 구현체나 `GitLabApiComponent` 같은 구체적인 기술 클래스를 직접 사용해서는 안되며, 항상 포트(인터페이스)를 통해 소통해야 함
        - 왜?:

3.  **프레젠테이션 계층 로직 포함**
    *   HTTP 세션 관리, JSON 파싱 등과 같은 표현 로직을 포함해서는 아니됨

4.  **도메인 엔티티를 그대로 반환**
    *   프레젠테이션 계층으로 데이터를 반환할 때는 반드시 DTO로 변환필요. 도메인 엔티티를 외부에 노출하면 도메인이 외부 계층에 강하게 결합되기 때문


### 3. 인프라스트럭처 계층 (Infrastructure Layer)
---

> 헥사고날 아키텍처의 **"아웃고잉 어댑터(Outgoing Adapter)"**. 도메인이 필요로 하는 외부 기술(DB, API, 메시징 큐 등)을 실제로 구현

###### ✅ 꼭 해야 하는 것 (Do's)

1.  **아웃고잉 포트(Outgoing Port) 구현**
    *   도메인 계층에 정의된 리포지토리 인터페이스를 구현하는 클래스(`RepositoryAdapter`)를 위치

2.  **외부 기술과 프레임워크 코드 집중**
    *   JPA, Spring Data JPA, MyBatis, `RestTemplate`, Kafka 클라이언트 등 모든 외부 기술 관련 코드는 이 계층에 위치해야 함.

3.  **데이터 매핑(Data Mapping)**
    *   도메인 엔티티와 데이터베이스 모델(JPA Entity 등) 간의 상호 변환을 책임지며, 이를 통해 도메인의 독립성을 지킬 수 있음.

4.  **외부 API 연동 및 예외 처리**
    *   외부 서비스 호출 시 발생하는 기술적인 예외(예: `GitLabApiException`)를 처리하고, 필요하다면 애플리케이션에서 이해할 수 있는 예외로 변환해 던져야 함

###### ❌ 절대로 하면 안 되는 것 (Don'ts)

1.  **비즈니스 로직 포함**
    *   어댑터는 오직 '번역'과 '연결'의 역할만 수행해야 하며, 비즈니스 규칙을 포함해서는 아니됨.

2.  **애플리케이션 또는 도메인 계층에 직접 의존 (포트 제외)**
    *   인프라스트럭처는 도메인에 정의된 포트(인터페이스)를 구현할 뿐, 애플리케이션 서비스나 도메인 엔티티의 내부 로직을 직접 호출해서는 아니됨.


### 4. 프레젠테이션 계층 (Presentation Layer) / 인터페이스 계층
---

> 헥사고날 아키텍처의 **"인커밍 어댑터(Incoming Adapter)"**. 외부(사용자, 다른 시스템)로부터의 요청을 받아들이는 진입점.

###### ✅ 꼭 해야 하는 것 (Do's)

1.  **애플리케이션 계층(유스케이스)에 의존**
    *   REST 컨트롤러, gRPC 엔드포인트, 메시지 큐 리스너 등은 애플리케이션 서비스(유스케이스 인터페이스)를 주입받아 호출해야 함.

2.  **데이터 변환(DTO)**
    *   외부 요청(예: JSON)을 DTO로 변환하여 애플리케이션 계층에 전달하고, 애플리케이션 계층이 반환한 DTO를 외부 응답(예: JSON)으로 변환하는 책임짐

3.  **전송 프로토콜 관련 책임 수행**
    *   HTTP 상태 코드 관리, 헤더 설정, 인증 토큰 검증 등 웹/API 프로토콜과 관련된 모든 것을 처리함.

###### ❌ 절대로 하면 안 되는 것 (Don'ts)

1.  **비즈니스 로직 또는 유스케이스 로직 포함**
    *   컨트롤러는 최대한 얇게(thin) 유지되어야 하며, 요청을 받아서 적절한 애플리케이션 서비스에 넘기는 역할만 수행해야 함.

2.  **도메인 또는 인프라스트럭처 계층에 직접 접근**
    *   컨트롤러가 리포지토리를 직접 호출하거나 도메인 엔티티를 직접 생성하는 것은 최악의 안티패턴. 이는 아키텍처를 완전히 무너뜨리는 행위임.



### 5. 요약 (Must Be)
---
#### presentation

#### application
- **로직 구현 X**
    - 구현하지마세요, 애그리거트(도메인)에 양보하세요
- **구현체 의존 X**
    - 포트만 의존(InComing, Outgoing)

#### domain
- **Only 규칙코드만 존재 (외부 의존성 의존X)**
    - 외부 의존성 X
        - 파일 시스템 접근 로직 X
        - 데이터베이스 접근 로직 X
    - Do Not Know Application Layer (+ DTO)

#### infrastrucure
- **비즈니스X**
- **도메인, 애플리케이션계층에 직접의존 X**

### 6. Packge Structure 예시
---

```
org.example.demo/
├── presentation/                           
│   └── branch/
│       ├── api/
│       │   └── BranchManagementController.java
│       └── dto/                            
│
├── application/
│   └── branch/
│       └── port
│           ├── service
│           │   └── LockBranchService.java
│           ├── in
│           │   └── LockBranchUseCase.java
│           └── out
│               ├── BranchDetail.java               # OutGoingDTO Param
│               └── BranchLockPort.java
├── domain/                                 
│   └── branch/             
│       └── model 
│	 	 	  ├── BranchName.java                   # VO
│	 	 	  └── Branch.java                       # Domain
│
└── infrastructure/                         
    ├── persistence/                        
    │   ├── repository/
    │   ├── mapper/
    │   └── model/
    └── branch/                           
        └── GitLabBranchAdapter.java
            ├── PipelineClient.java
            └── NotificationClient.java
```



### 회고
---
도메인 설계를 하면서 가장 크게 느낀 점은 도메인 레벨에서의 유효성 검사는 곧 도메인 로직이라는 것. 금액이 음수가 될 수 없다거나, 특정 상태에서만 다음 상태로 전이할 수 있다는 규칙은 도메인 자체의 불변 조건에 해당하기 때문에, 반드시 엔티티나 밸류 객체 안에서 보장되어야 한다. 반대로 입력 값의 포맷이나 필수 여부와 같이 외부 요청을 방어하는 검증은 애플리케이션 계층에서 처리하는 것이 더 적합하며, 이 둘을 명확히 구분하지 않으면 도메인 객체가 책임을 잃고 단순한 데이터 컨테이너로 전락하게 될것.

특히 도메인 모델이 빈약해질 때 나타나는 전형적인 형태가 바로 Anemic Domain Model이다. 이 경우 객체는 필드와 getter/setter만 남고, 정작 중요한 규칙들은 서비스 계층이나 컨트롤러에 흩어져 절차적으로 구현된다. 그리고 그 결과는 도메인 모델이 사실상 DTO와 크게 다르지 않게 되어 버린다.

추가적으로, 모든 시스템에 도메인 주도개발이 필요한 것은 아니다, 단순한 CRUD 위주의 기능만 제공하는 경우라면 특정 도메인에 대한 비즈니스 규칙을 옮겨야하는데 규칙이 없는경우, 도메인 주도 개발이 어렵다. 예를 들어 공지사항이나 게시판처럼 데이터 저장과 조회가 전부인 기능은 빈약한 도메인 모델만으로도 충분하다.(영속성 객체를 DTO에 Wrapping 해 전달하면 그만..) 하지만 업무 규칙이 복잡해지고 상태 전이나 계산 로직 같은 비즈니스 제약이 등장하는 순간, 그 책임을 도메인 내부로 옮겨 풍부한 도메인 모델을 갖추는 것이 필수적이다.






<!-- 도메인 레벨의 유효성 검사 = 도메인 로직 -->
<!---->
<!-- 비즈니스 규칙과 불변 조건은 반드시 도메인 모델 내부에서 다루어야 한다. -->
<!---->
<!-- 예: 주문 금액은 0원 미만일 수 없다, 상태 전이는 특정 조건을 만족해야만 가능하다. -->
<!---->
<!-- 이런 규칙을 엔티티/밸류 객체에 포함시켜야 풍부한 도메인 모델을 구성할 수 있다. -->
<!---->
<!-- 애플리케이션 레벨의 유효성 검사 -->
<!---->
<!-- 요청 형식이나 외부 시스템과의 통신 관련 검증은 애플리케이션 계층에서 다루는 것이 적절하다. -->
<!---->
<!-- 예: RequestBody 필수 값 확인, 인증/인가 확인, 포맷 검증 등. -->
<!---->
<!-- 이는 비즈니스 규칙이 아니라 "입력값 방어" 성격에 가깝다. -->
<!---->
<!-- 빈약한 도메인 모델 (Anemic Domain Model) -->
<!---->
<!-- 도메인 객체가 단순히 데이터 구조(필드 + getter/setter)에 불과한 경우. -->
<!---->
<!-- 규칙이 서비스 계층이나 컨트롤러에 분산되어 절차적 코드가 되기 쉽다. -->
<!---->
<!-- 결과적으로 도메인 객체는 본연의 역할을 잃고 DTO와 다를 바 없어짐. -->
<!---->
<!-- 간단한 CRUD일수록 도메인은 빈약하다 (오버헤드) -->
<!---->
<!-- "공지사항, 게시판"처럼 단순히 데이터 저장·조회만 필요한 경우, 복잡한 도메인 모델을 억지로 만들면 오히려 오버헤드가 된다. -->
<!---->
<!-- 이럴 땐 데이터 중심 설계(빈약한 도메인 모델)로도 충분하다. -->
<!---->
<!-- 하지만 복잡한 규칙이 요구되는 순간, 반드시 도메인 로직을 모델 내부로 이동시켜야 한다. -->

<!-- 도메인 레벨의 유효성검사 == 도메인 로직 -->
<!-- 애플리케이션 레벨의 유효성검사 -->
<!-- Anemic Domain Model  -->
<!-- 간단한 CRUD일수록 도메인은 빈약하다 (오버헤드) -->


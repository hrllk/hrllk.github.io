---
title: anomalies of concurrency
categories:
   - database
---

### Overview
---

동시성 == 이상현상<br>
데이터베이스 시스템에서 트랜잭션을 통해 데이터를 조작할 때 발생할 수 있는 이슈<br>
데이터의 일관성을 해칠 수 있기 때문에(이상현상) 트랜잭션 격리 수준 [!] 을 통해 제어됨<br>


### Anomalies
---

1.  **Dirty Read**:
    - 설명: 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는것
    - 문제점: 데이터를 변경한 트랜잭션이 만약 어떤 이유로 롤백이되는경우, 이름 참조했던 트랜잭션은 무효한 데이터를 기반으로 작업을 수행하게되며 이는 데이터 불일치를 야기
    - 예시: 
        1. 트랜잭션 A: 특정 상품의 재고를 변경 100 > 90
        2. 트랜잭션 B: 계산된 재고를 다른 트랜잭션에서 비즈니스에 사용
        3. 트랜잭션 A: 비즈니스 수행중 어떤 사유에대해 해당 트랜잭션이 롤백되는 경우 B트랜잭션과의 무결성이 깨짐

        <!-- 1. 트랜잭션 A가 어떤 상품의 재고를 100에서 90으로 변경 (아직 커밋하지 않음) -->
        <!-- 2. 이때 트랜잭션 B가 이 상품의 재고를 90으로 읽어 다른 계산에 사용 -->
        <!-- 3. 만약 트랜잭션 A가 롤백되어 재고가 다시 100이 되면, 트랜잭션 B는 잘못된 90이라는 값으로 작업을 진행한 것이 됩니다. -->
2.  **Non-Repeatable Read**:
    - 설명: 하나의 트랜잭션에서 같은 쿼리를 두번 수행한다고 했을 때, 동일한 쿼리 사이에 다른 트랜잭션이 데이터를 수정하고 커밋했다면 두 쿼리의 결과가 다르게 나타날 수 있음
    - 문제점: 트랜잭션 도중에 데이터가 변경되어 일관된 결과를 얻지 못하게됨 (UPDATE)
    - 예시: 
        1. 트랜잭션 A: "철수" 라는 회원의 전화번호를 조회
        2. 트랜잭션 B: "철수" 회원에 대해 전화번호를 변경
        3. 트랜잭션 A: 다시 해당 회원의 정보를 조회했을 때 첫번째 조회했을 때 취득한 전화번호와 다름

3.  **Phantom Read**:
    - 설명: 하나의 트랜잭션에서 같은 쿼리를 두번 수행한다고 했을 때, 동일한 쿼리 사이에 다른 트랜잭션에의해 데이터가 추가되거나 삭제되는 현상
    - 문제점: 트랜잭션 도중에 데이터가 변경되어 일관된 결과를 얻지 못하게됨 (INSERT, DELETE)
    - 예시: 
        1. 트랜잭션 A: 특정 지역에 거주하는 고객의 수 조회
        2. 트랜잭션 B: 해당 지역에 새로운 고객을 추가하고 커밋
        3. 트랜잭션 A: 다시 해당 지역에 거주하는 고객수를 조회했을 때 한명 더 많은 고객이 조회됨



### Conclusion

---

데이터베이스 동시성 문제는 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 해칠 수 있는 중요한 문제<br>
문제를 이해하고 적절한 트랜잭션 격리 수준을 선택해 안정적이고 효율적인 데이터베이스 시스템을 구축하는데 필수적<br>

<!---->
<!---->
<!--     *   **설명**: 하나의 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때, 첫 번째 쿼리에서는 없던 '유령(Phantom)' 레코드가 두 번째 쿼리에서 나타나거나, 있던 레코드가 사라지는 현상입니다. -->
<!--     *   **문제점**: 주로 `INSERT` 또는 `DELETE` 작업 때문에 발생합니다. 범위(range) 기반의 쿼리에서 특히 문제가 됩니다. 이로 인해 트랜잭션의 일관된 뷰가 깨질 수 있습니다. -->
<!--     *   **예시**: 트랜잭션 A가 '서울' 지역에 사는 고객의 수를 조회합니다. 그 사이에 트랜잭션 B가 '서울'에 사는 새로운 고객을 추가하고 커밋합니다. 트랜잭션 A가 다시 '서울' 지역 고객의 수를 조회했을 때, 첫 번째 조회보다 한 명 더 많은 고객이 나타납니다. -->
<!---->
<!---->
<!---->
<!-- ### 주요 동시성 문제 (Main Concurrency Anomalies) -->
<!---->
<!-- 1.  **Dirty Read (더티 읽기)**: -->
<!--     *   **설명**: 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 현상입니다. '오손 읽기'라고도 합니다. -->
<!--     *   **문제점**: 만약 데이터를 변경한 트랜잭션이 어떤 이유로 인해 롤백된다면, 이 데이터를 읽었던 트랜잭션은 유효하지 않은(무효한) 데이터를 기반으로 작업을 수행하게 됩니다. 이는 데이터 불일치를 야기할 수 있습니다. -->
<!--     *   **예시**: 트랜잭션 A가 어떤 상품의 재고를 100에서 90으로 줄였지만 아직 커밋하지 않았습니다. 이때 트랜잭션 B가 이 상품의 재고를 90으로 읽어 다른 계산에 사용합니다. 만약 트랜잭션 A가 롤백되어 재고가 다시 100이 되면, 트랜잭션 B는 잘못된 90이라는 값으로 작업을 진행한 것이 됩니다. -->
<!---->
<!-- 2.  **Non-Repeatable Read (반복 불가능 읽기)**: -->
<!--     *   **설명**: 하나의 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때, 그 사이에 다른 트랜잭션이 데이터를 수정하고 커밋하여 두 쿼리의 결과가 다르게 나타나는 현상입니다. '재현 불가능 읽기'라고도 합니다. -->
<!--     *   **문제점**: 트랜잭션 도중에 데이터가 변경되어 일관된 결과를 얻지 못하게 됩니다. 이는 트랜잭션의 예측 가능성을 떨어뜨립니다. -->
<!--     *   **예시**: 트랜잭션 A가 회원 '철수'의 정보를 조회합니다. 그 사이에 트랜잭션 B가 '철수'의 전화번호를 변경하고 커밋합니다. 트랜잭션 A가 다시 '철수'의 정보를 조회했을 때, 첫 번째 조회와 다른 전화번호를 얻게 됩니다. -->
<!---->
<!-- 3.  **Phantom Read (팬텀 읽기)**: -->
<!--     *   **설명**: 하나의 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때, 첫 번째 쿼리에서는 없던 '유령(Phantom)' 레코드가 두 번째 쿼리에서 나타나거나, 있던 레코드가 사라지는 현상입니다. -->
<!--     *   **문제점**: 주로 `INSERT` 또는 `DELETE` 작업 때문에 발생합니다. 범위(range) 기반의 쿼리에서 특히 문제가 됩니다. 이로 인해 트랜잭션의 일관된 뷰가 깨질 수 있습니다. -->
<!--     *   **예시**: 트랜잭션 A가 '서울' 지역에 사는 고객의 수를 조회합니다. 그 사이에 트랜잭션 B가 '서울'에 사는 새로운 고객을 추가하고 커밋합니다. 트랜잭션 A가 다시 '서울' 지역 고객의 수를 조회했을 때, 첫 번째 조회보다 한 명 더 많은 고객이 나타납니다. -->
<!---->
<!-- ### 동시성 문제 방지 및 격리 수준 (Preventing Concurrency Issues and Isolation Levels) -->
<!---->
<!-- 이러한 동시성 문제들은 데이터베이스의 트랜잭션 격리 수준을 조정함으로써 방지할 수 있습니다. 각 격리 수준은 특정 동시성 문제를 허용하거나 방지하며, 높은 격리 수준일수록 더 많은 동시성 문제를 방지하지만, 동시성 처리량은 낮아지고 성능 저하를 가져올 수 있습니다. -->
<!---->
<!-- *   **READ_UNCOMMITTED**: Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능. -->
<!-- *   **READ_COMMITTED**: Dirty Read 방지. Non-Repeatable Read, Phantom Read 발생 가능. -->
<!-- *   **REPEATABLE_READ**: Dirty Read, Non-Repeatable Read 방지. Phantom Read 발생 가능. -->
<!-- *   **SERIALIZABLE**: 모든 동시성 문제(Dirty Read, Non-Repeatable Read, Phantom Read) 방지. -->
<!---->
<!-- ### 결론 (Conclusion) -->
<!-- 데이터베이스 동시성 문제는 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 해칠 수 있는 중요한 문제입니다. 이러한 문제들을 이해하고 적절한 트랜잭션 격리 수준을 선택하는 것은 안정적이고 효율적인 데이터베이스 시스템을 구축하는 데 필수적입니다. 애플리케이션의 특성과 요구되는 데이터 무결성 수준을 고려하여 최적의 격리 수준을 결정해야 합니다. -->


---
title: Java 객체가 메모리에 올라가는 과정 (new ~ GC 대상까지)
categories:
  - cs
  - jvm
published: false
---

### overview
---

이거 헷갈리면 JVM/GC 계속 꼬임.
먼저 한 줄로 정리:

- 객체 본체(실제 값) = 힙
- 참조 변수 = 스택(지역변수 기준)

흐름은 이거 하나면 끝남.
new → 힙 생성 → 참조 연결 → 참조 끊김 → GC 후보

### 1) new 하면 실제로 뭐가 생기냐
---

코드:
User user = new User("alzar");

실행 순서:
1. 힙에 User 객체 공간 생성
2. 필드 초기화 + 생성자 실행
3. 스택의 user 변수에 "힙 객체 주소(참조)" 저장

즉,
- 진짜 데이터(name 등)는 힙
- user 변수는 주소표 들고 있는 포인터 느낌

### 2) 스택/힙 한 번에 정리
---

- 스택: 메서드 지역변수, 참조 변수
- 힙: new로 만든 객체 본체

자주 하는 착각:
"실제 값이 스택이고, 힙은 참조만" → 틀림.
반대임.

### 3) GC 대상은 언제 되나
---

GC 핵심은 "참조가 남아있냐"임.

- 참조가 하나라도 있으면 객체 생존
- 참조가 전부 끊기면 GC 후보

참조 끊기는 케이스:
- user = null
- 메서드 종료(지역변수 소멸)
- 컬렉션에서 제거

주의:
GC 후보 = 즉시 삭제 아님.
다음 GC 사이클 때 회수됨.

### 4) 실무에서 메모리 새는 패턴
---

- static 컬렉션에 객체 계속 적재
- 캐시 eviction 없이 무한 적재
- 전역 Map에 세션/DTO 참조 오래 유지

코드는 끝났는데 메모리 안 떨어지는 이유가 대체로 이거임.

### 5) 체크리스트
---

- 긴 생명주기 컬렉션에 불필요 객체가 쌓이는지
- static 필드가 참조를 오래 잡고 있는지
- 요청 객체를 전역으로 보관하는 코드가 있는지
- GC 이후에도 Old 영역이 계속 우상향하는지

### 요약
---

객체 생명주기는 "참조" 게임임.

- 참조 있으면 생존
- 참조 끊기면 GC 후보

JVM 메모리 이슈는 객체 개수보다
"누가 참조를 안 놓고 있나"를 먼저 보면 됨.
